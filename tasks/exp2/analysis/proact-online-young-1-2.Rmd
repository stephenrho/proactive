---
title: "Proactive online - Experiment 1 vs 2 younger adults"
output:
  pdf_document: default
  html_document: default
urlcolor: blue
---

```{r setup, include=FALSE}

library(plyr)
library(ez)
library(lme4)
library(psych)

source("../../exp1/analysis/useful_functions.R")

knitr::opts_chunk$set(echo = F, message = F, warning = F)
```

```{r, results="hide"}

# read data
e1_wm = read.csv("../../exp1/analysis/exp1_wm.csv", stringsAsFactors = F)
e1_learn = read.csv("../../exp1/analysis/exp1_learn.csv", stringsAsFactors = F)

e1_wm = subset(e1_wm, group == "younger")
e1_learn = subset(e1_learn, group == "younger")

e2_wm = read.csv("exp2_wm.csv", stringsAsFactors = F)
e2_learn = read.csv("exp2_learn.csv", stringsAsFactors = F)
e2_search = read.csv("exp2_search.csv", stringsAsFactors = F)

e2_wm = subset(e2_wm, group == "younger")
e2_learn = subset(e2_learn, group == "younger")
e2_search = subset(e2_search, group == "younger")

# put together
e1_wm$exp = e1_learn$exp = 1
e2_wm$exp = e2_learn$exp = e2_search$exp = 2

wm_cols = union(colnames(e1_wm), colnames(e2_wm))
wm_cols = wm_cols[!(wm_cols %in% 
                      c(setdiff(colnames(e1_wm), colnames(e2_wm)),
                        setdiff(colnames(e2_wm), colnames(e1_wm))))]

learn_cols = union(colnames(e1_learn), colnames(e2_learn))
learn_cols = learn_cols[!(learn_cols %in% 
                            c(setdiff(colnames(e1_learn), colnames(e2_learn)),
                              setdiff(colnames(e2_learn), colnames(e1_learn))))]

wm_dat = rbind(e1_wm[, wm_cols], e2_wm[, wm_cols])
learn_dat = rbind(e1_learn[, learn_cols], e2_learn[, learn_cols])

# misc 
ids = list(
  unique(wm_dat$participant[wm_dat$exp==1]),
  unique(wm_dat$participant[wm_dat$exp==2])
)

print_mci = function(x){
  sprintf("%.3f [%.3f, %.3f]", mean(x), quantile(x, .025), quantile(x, .975))
}

```

# Summary

In a previous online experiment older adults showed some evidence of proactive interference in a working memory task from previously learned image-word pairs, whereas there was no evidence of PI for the younger adults (results described [here](https://www.dropbox.com/s/zdhbqs95xxojf4b/proact-online.pdf?dl=0)). In a previous lab study we had found that both younger and older groups exhibited evidence of PI. In the lab study there was 10 s of distraction separating study and cued recall in the WM task, whereas in the online study there was a 2 s blank interval. Thus, to follow up on the first online study we modified the task to include a 2 s search task between study and test where participants searched for a target square among 7 non-targets and made a response on the identity of the target (what side a square shape was open, left/right). The expectation was that this would lead to clear PI for younger adults if items were 'displaced' from WM. Here we compare the performance of younger adults without distraction (experiment 1) to those with distraction (experiment 2).

# Participants

49 and 47 younger adults (18-35 years old) were recruited from prolific and provided completed data sets for Experiments 1 and 2, respectively.

# Learning

```{r}

# find bad performers
learn_overall = ddply(learn_dat, c("participant", "exp"), summarize,
                  N = length(recall_acc), 
                  acc = mean(recall_acc),
                  mean_rt = mean(recalled_rt),
                  prop_noresp = mean(recalled %in% c("?", "")))

#learn_overall[learn_overall$acc < .5,]


learn_agg = ddply(learn_dat, c("participant", "exp", "learn_block"), summarize,
                  N = length(recall_acc), 
                  acc = mean(recall_acc),
                  mean_rt = mean(recalled_rt),
                  prop_noresp = mean(recalled %in% c("?", "")))

learn_agg$learn_block = factor(learn_agg$learn_block, levels = c("1", "2", "3", "final test"))

learn_mse = summarySEwithin(data = learn_agg, measurevar = "acc", betweenvars = "exp", withinvars = "learn_block")


### plot 1: overall performance in each learning block + final test performance

jitts = c(-.05, .05)
cols = c("violet", "forestgreen")

plot(NA, xlim=c(.7,4.3), ylim=c(0,1), xlab="", ylab="Recall Accuracy", axes=F)
#box()
axis(1, at = 1:4, labels = c("Block 1", "Block 2", "Block 3", "Final Test"))
axis(2)

for (g in 1:2){
  # individual data points
  l_ply(.data = ids[[g]], .fun = function(x) with(subset(learn_agg, participant==x), points(jitter(as.numeric(learn_block)+jitts[g], amount = .025), acc, pch=16, col=faintCol(cols[g]), type='p')))
}
for (g in 1:2){
  # error bars
  with(subset(learn_mse, exp==g), errBars(means = acc, error = se, xpos = as.numeric(learn_block)+jitts[g]))
  # points
  with(subset(learn_mse, exp==g), points(as.numeric(learn_block)+jitts[g], acc, pch=16, col=cols[g], type='b'))
}

legend("bottomright", legend = c("1", "2"), title = "Experiment", pch=16, col=cols, bty='n')

mtext("Recall accuracy for learning phase", font=2, line=1, adj=0)

mtext("(Note: participants kept doing blocks\nuntil they got 80% or had done 3)", side = 1, line=4, adj=0)


## analysis
# compare final learning performance
learn_dat$exp = as.factor(learn_dat$exp)
contrasts(learn_dat$exp) = c(-1,1)

learn_m1 = glmer(recall_acc ~ exp + (1 | participant), 
                 data = subset(learn_dat, learn_block=="final test"), 
                 family = binomial(link = "logit"))

# summary(learn_m1)

```

The figure above presents data from the learning phase, which was the same in both experiments (only the WM task differed). Participants looped through the pairs in groups of 10 until they got 80% or more correct or they had completed three loops. The table below shows how many participants completed the different 'stages' of learning (all participants did at least one loop and the final test):

```{r}
knitr::kable(table(learn_agg$exp, learn_agg$learn_block))
```

Accuracy in the final test was analysed using a generalized mixed effects model with fixed effect of experiment group (1 vs. 2) and random participant intercept. The two groups do not significantly differ in their performance at the end of the learning phase, `r print_coef(learn_m1, eff=2)`.

# Working memory

```{r}

wm_overall = ddply(wm_dat, c("participant", "exp"), summarize,
                   N = length(recall_acc),
                   acc = mean(recall_acc),
                   mean_rt = mean(recall_rt))

# hist(wm_overall$acc)
# wm_overall[wm_overall$acc <.2,]


wm_agg = ddply(wm_dat, c("participant", "exp", "item_type"), summarize,
                   N = length(recall_acc),
                   acc = mean(recall_acc),
                   mean_rt = mean(recall_rt))
            # need to add these columns 
                   #acc_lax = mean(prop_lett > .8),
                   #ltm_int = mean(ltm_intru))

wm_agg$item_type = as.factor(wm_agg$item_type)

wm_mse = summarySEwithin(data = wm_agg, measurevar = "acc", betweenvars = "exp", withinvars = "item_type")


### plot 2: performance in the wm task by item type

plot(NA, xlim=c(.7,4.3), ylim=c(0,1), xlab="", ylab="Recall Accuracy", axes=F)
#box()
axis(1, at = 1:4, labels = levels(wm_agg$item_type))
axis(2)

for (g in 1:2){
  # individual data points
  l_ply(.data = ids[[g]], .fun = function(x) with(subset(wm_agg, participant==x), points(jitter(as.numeric(item_type)+jitts[g], amount = .025), acc, pch=16, col=faintCol(cols[g]), type='p')))
}
for (g in 1:2){
  # error bars
  with(subset(wm_mse, exp==g), errBars(means = acc, error = se, xpos = as.numeric(item_type)+jitts[g]))
  # points
  with(subset(wm_mse, exp==g), points(as.numeric(item_type)+jitts[g], acc, pch=16, col=cols[g], type='b'))
}

legend("bottomright", legend = c("1 (no distraction)", "2 (distraction)"), title = "Experiment", pch=16, col=cols, bty='n')

mtext("Working memory performance by item type", font=2, line=1, adj=0)


# # analysis
wm_dat$item_type = as.factor(wm_dat$item_type)
wm_dat$exp = as.factor(wm_dat$exp)

contrasts(wm_dat$item_type) = cbind(matchVrest = c(1,-1/3,-1/3,-1/3),
                                        newVnonmatch=c(0,-1/2,1,-1/2),
                                        mismatchVoldnew=c(0,1,0,-1))
contrasts(wm_dat$exp) = c(-1,1)

wm_m1 = glmer(recall_acc ~ 1 + exp*item_type + (1 + item_type | participant),
              data = wm_dat,
              family = binomial(link = "logit"))

#summary(wm_m1)

wm_m1_an = car::Anova(wm_m1)

# wm_m1.1 = glmer(recall_acc ~ 1 + item_type + (1 + item_type | participant),
#               data = subset(wm_dat, exp==1),
#               family = binomial(link = "logit"))
# 
# wm_m1.2 = glmer(recall_acc ~ 1 + item_type + (1 + item_type | participant),
#               data = subset(wm_dat, exp==2),
#               family = binomial(link = "logit"))

# summary(wm_m1.y)
# summary(wm_m1.o)

# recode item type
wm_dat$pif = "new-new"
wm_dat$pif[wm_dat$item_type == "match"] = "match"
wm_dat$pif[wm_dat$item_type %in% c("old-new", "mis-match")] = "non-match"

wm_dat$pif = as.factor(wm_dat$pif)

contrasts(wm_dat$pif) = cbind(PF = c(1,-1/2,-1/2),
                                        PI=c(0,1,-1))

wm_m2 = glmer(recall_acc ~ 1 + exp*pif + (1 + pif | participant),
              data = wm_dat,
              family = binomial(link = "logit"))

#summary(wm_m2)

#car::Anova(wm_m2)

# regular anova
wm_aov1 = ezANOVA(wm_agg, dv = acc, wid = participant,
                  within = item_type, between = exp)

# t_match = t.test(acc ~ group, data = subset(wm_agg, item_type=="match"), var.equal=T)
# t_new = t.test(acc ~ group, data = subset(wm_agg, item_type=="new-new"), var.equal=T)
# t_mismatch = t.test(acc ~ group, data = subset(wm_agg, item_type=="mis-match"), var.equal=T)
# t_oldnew = t.test(acc ~ group, data = subset(wm_agg, item_type=="old-new"), var.equal=T)

wm_aov2 = ezANOVA(subset(wm_agg, item_type != "match"), dv = acc, wid = participant,
                  within = item_type, between = exp)

```

Accuracy in the working memory task is presented above. This data is analyzed with a generalized mixed effects model (logistic regression), which is arguably more appropriate for this binary (correct/incorrect) data, and ANOVA. 

## Logistic model

For this analysis the factor of item type was coded so that (1) match items were compared to the other three item types, (2) new-new items were compared to mis-match and old-new items, and (3) mis-match items were contrasted with old-new items. For experiment group, experiment 1 was coded -1 and experiment 2 was coded +1. Random participant intercepts and effects of item type were also included.

The main effect of item type is significant, `r print_chi(wm_m1_an, 2)`, but the main effect of experiment group, `r print_chi(wm_m1_an, 1)`, and the group by item type interaction are not significant, `r print_chi(wm_m1_an, 3)`.

Looking at the more focused interaction contrasts, the difference between match items and the other items types (contrast 1) does not vary by group, `r print_coef(wm_m1, 6)`. The difference between new-new and the mis-match/old-new items (contrast 2; the slight difference in the figure) does not significantly differ by group, `r print_coef(wm_m1, 7)`. Finally, the difference between mis-match and old-new (contrast 3) also does not significantly vary by experiment group, `r print_coef(wm_m1, 8)`.

## ANOVA 

The table below presents the results of an ANOVA on accuracy. Again the main effect of group and the interaction are not significant.

```{r}
knitr::kable(wm_aov1$ANOVA, digits = 3)
```

## Search task performance

Before the working memory task participants completed 20 trials of the search task by itself. The first 4 trials are excluded as practice to leave 16 trials to compare search alone to the 16 responses during the WM task. The plot below shows accuracy and mean response times to the search task.

```{r}

search_agg = ddply(e2_search, c("participant", "section"), summarize,
                   N = length(accuracy),
                   acc = mean(accuracy),
                   prop_missed = mean(is.na(s_respright)),
                   mean_rt = mean(search_resp.rt, na.rm=T))

search_agg$section = as.factor(search_agg$section)

search_mse = summarySEwithin(data = search_agg, measurevar = "acc", withinvars = "section")
search_rt_mse = summarySEwithin(data = na.omit(search_agg), measurevar = "mean_rt", withinvars = "section")


par(mfrow=c(1,2)) ; g=2 # plot search accuracy and rt

# acc
plot(NA, xlim=c(.7,2.3), ylim=c(0,1), xlab="", ylab="Search Accuracy", axes=F)
#box()
axis(1, at = 1:2, labels = levels(search_agg$section))
axis(2)

# individual data points
l_ply(.data = ids[[2]], .fun = function(x) with(subset(search_agg, participant==x), points(jitter(as.numeric(section), amount = .025), acc, pch=16, col=faintCol(cols[g]), type='b')))

# error bars
with(search_mse, errBars(means = acc, error = se, xpos = as.numeric(section)))
# points
with(search_mse, points(as.numeric(section), acc, pch=16, col=cols[g], type='b'))

mtext("Search accuracy and RT", font=2, line=1, adj=0)

# rt
plot(NA, xlim=c(.7,2.3), ylim=c(0.5,2), xlab="", ylab="Search RT (s)", axes=F)
#box()
axis(1, at = 1:2, labels = levels(search_agg$section))
axis(2)

# individual data points
l_ply(.data = ids[[2]], .fun = function(x) with(subset(search_agg, participant==x), points(jitter(as.numeric(section), amount = .025), mean_rt, pch=16, col=faintCol(cols[g]), type='b')))

# error bars
with(search_rt_mse, errBars(means = mean_rt, error = se, xpos = as.numeric(section)))
# points
with(search_rt_mse, points(as.numeric(section), mean_rt, pch=16, col=cols[g], type='b'))


# analysis of search acc/rt
e2_search$section = as.factor(e2_search$section)
contrasts(e2_search$section) = c(-1,1)

search_acc_m1 = glmer(accuracy ~ section + (1 | participant), data = e2_search, family = binomial) # wont converge with random effect 

search_rt_m1 = lmer(search_resp.rt ~ section + (1 + section | participant), data = e2_search)

```

Mixed effects models find that accuracy does not significantly differ between search alone and search + WM, `r print_coef(search_acc_m1, 2)`, whereas RT is slower with the WM task, $b$ = 0.08 (SE = 0.01), $t$ = 5.59, $p <$ 0.05.

### Excluding low search performers

```{r}

# exclude low search performers and re-do wm model
search_thresh = .6

low_search = search_agg$participant[with(search_agg, acc < search_thresh & section == "wm")]

wm_agg2 = ddply(subset(wm_dat, !(participant %in% low_search)), c("participant", "exp", "item_type"), summarize,
                   N = length(recall_acc),
                   acc = mean(recall_acc),
                   mean_rt = mean(recall_rt))

wm_agg2$item_type = as.factor(wm_agg2$item_type)

wm_mse2 = summarySEwithin(data = wm_agg2, measurevar = "acc", betweenvars = "exp", withinvars = "item_type")


### plot 2: performance in the wm task by item type

plot(NA, xlim=c(.7,4.3), ylim=c(0,1), xlab="", ylab="Recall Accuracy", axes=F)
#box()
axis(1, at = 1:4, labels = levels(wm_agg2$item_type))
axis(2)

for (g in 1:2){
  # individual data points
  l_ply(.data = ids[[g]], .fun = function(x) with(subset(wm_agg2, participant==x), points(jitter(as.numeric(item_type)+jitts[g], amount = .025), acc, pch=16, col=faintCol(cols[g]), type='p')))
}
for (g in 1:2){
  # error bars
  with(subset(wm_mse2, exp==g), errBars(means = acc, error = se, xpos = as.numeric(item_type)+jitts[g]))
  # points
  with(subset(wm_mse2, exp==g), points(as.numeric(item_type)+jitts[g], acc, pch=16, col=cols[g], type='b'))
}

legend("bottomright", legend = c("1 (no distraction)", "2 (distraction)"), title = "Experiment", pch=16, col=cols, bty='n')

mtext("Working memory: excluding low search accuracy participants", font=2, line=1, adj=0)


## 
wm_m3 = glmer(recall_acc ~ 1 + exp*item_type + (1 + item_type | participant),
              data = subset(wm_dat, !(participant %in% low_search)),
              family = binomial(link = "logit"))

wm_m3_an = car::Anova(wm_m3)

# summary(wm_m1)
# summary(wm_m3)

```

In the search task figure above there are some participants who may have not engaged much with the distracting search task, resulting in low accuracy. Therefore, an additional analysis of the working memory data was performed in which participants with accuracy less than `r round(search_thresh*100)`% in the search task, when performed alongside the WM task, are excluded. This results in the exclusion of `r length(low_search)` participants and WM accuracy following this exclusion is presented in the figure above.

In an additional mixed effects analysis the main effect of item type is significant, `r print_chi(wm_m3_an, 2)`, and the main effect of experiment group is not, `r print_chi(wm_m3_an, 1)`. However, the group by item type interaction is significant in this analysis, `r print_chi(wm_m3_an, 3)`. As can be seen in the figure this is driven by better performance in Experiment 2 for the match, mis-match, and old-new item types. Performance for new-new items is approximately the same. Thus, there was no PI even for participants who engaged with the distracting task.

# Summary

- The 2 s search task does not appear to have influenced performance overall or for particular item types in the working memory task
- Some options for future experiments:
    - modify this task to make it more demanding (e.g., more non-targets)
    - find a more demanding task that will fit into 2 s
    - lengthen the retention interval beyond 2 s and have multiple search responses instead of just one (we would probably then also need to run a version with a longer blank interval to compare to)